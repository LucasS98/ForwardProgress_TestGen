(* generated by lnt2lotos 6.8 *)

type COMMON is LNTEXTENSIONS, LNTEXCEPTIONS
   sorts
      NATSET (*! list *),
      MEMARRAY,
      MEMLOC (*! implementedby ADT_RANGE__MEMLOC comparedby ADT_RANGE_CMP__MEMLOC iteratedby ADT_RANGE_ENUM_FIRST__MEMLOC and ADT_RANGE_ENUM_NEXT__MEMLOC printedby ADT_RANGE_PRINT__MEMLOC external *),
      INSTRUCTION,
      PROGRAM (*! list *)
   opns
      (* definitions for type NATSET *)
      NIL (*! constructor *) :  -> NATSET
      CONS (*! constructor *) : NAT, NATSET -> NATSET
      delete : NAT, NATSET -> NATSET
      INSERT (*! implementedby INSERT__NATSET__GENERATED *) : NAT, NATSET -> NATSET
      length : NATSET -> NAT
      remove : NAT, NATSET -> NATSET
      member : NAT, NATSET -> BOOL
      GET__1 : NATSET -> NAT
      GET__2 : NATSET -> NATSET

      (* definitions for type MEMARRAY *)
      MEMARRAY (*! constructor *) : INT, INT -> MEMARRAY
      MEMARRAY : INT -> MEMARRAY
      ARRAY__GET (*! implementedby ARRAY__GET__MEMARRAY__GENERATED *) : MEMARRAY, NAT -> INT
      ARRAY__SET (*! implementedby ARRAY__SET__MEMARRAY__GENERATED *) : MEMARRAY, NAT, INT -> MEMARRAY
      GET__1 : MEMARRAY -> INT
      GET__2 : MEMARRAY -> INT

      (* definitions for type MEMLOC *)
      CONSTRUCTOR__MEMLOC (*! implementedby ADT_RANGE_CONSTRUCTOR__MEMLOC constructor external *) : NAT -> MEMLOC
      NAT : MEMLOC -> NAT
      MEMLOC (*! implementedby ADT_RANGE_CAST__MEMLOC__GENERATED *) : NAT -> MEMLOC
      MEMLOC : MEMLOC -> MEMLOC

      (* definitions for type INSTRUCTION *)
      ATOMIC_EXCH_BRANCH (*! constructor *) : MEMLOC, INT, BOOL, INT, NAT, BOOL -> INSTRUCTION
      GET_CHECK_LOC (*! implementedby GET_CHECK_LOC__INSTRUCTION__GENERATED *) : INSTRUCTION -> MEMLOC
      GET_EXCH_VAL (*! implementedby GET_EXCH_VAL__INSTRUCTION__GENERATED *) : INSTRUCTION -> INT
      GET_DO_EXCH (*! implementedby GET_DO_EXCH__INSTRUCTION__GENERATED *) : INSTRUCTION -> BOOL
      GET_CHECK_VAL (*! implementedby GET_CHECK_VAL__INSTRUCTION__GENERATED *) : INSTRUCTION -> INT
      GET_BRANCH_TARGET (*! implementedby GET_BRANCH_TARGET__INSTRUCTION__GENERATED *) : INSTRUCTION -> NAT
      GET_DO_BRANCH (*! implementedby GET_DO_BRANCH__INSTRUCTION__GENERATED *) : INSTRUCTION -> BOOL
      GET__1 : INSTRUCTION -> MEMLOC
      GET__2 : INSTRUCTION -> INT
      GET__3 : INSTRUCTION -> BOOL
      GET__4 : INSTRUCTION -> INT
      GET__5 : INSTRUCTION -> NAT
      GET__6 : INSTRUCTION -> BOOL

      (* definitions for type PROGRAM *)
      NIL (*! constructor *) :  -> PROGRAM
      CONS (*! constructor *) : INSTRUCTION, PROGRAM -> PROGRAM
      access (*! implementedby ADT_ACCESS__PROGRAM__GENERATED *) : PROGRAM, NAT -> INSTRUCTION
      length : PROGRAM -> NAT
      GET__1 : PROGRAM -> INSTRUCTION
      GET__2 : PROGRAM -> PROGRAM

      (* operations for LNT function definitions *)
      NUMMEMLOC :  -> NAT
      CHECK__CHANNEL__NATCHAN : NAT -> BOOL
      CHECK__CHANNEL__EXCHAN : NAT, INSTRUCTION, NATSET, NAT -> BOOL

   eqns
      (* equations for LNT type definitions *)
      ofsort NATSET
      forall VAR__X, VAR__Y : NAT, VAR__TAIL : NATSET
         delete (VAR__X, NIL of NATSET) = NIL of NATSET;
         delete (VAR__X, CONS (VAR__X, VAR__TAIL)) = VAR__TAIL;
         (VAR__X < VAR__Y) => delete (VAR__X, CONS (VAR__Y, VAR__TAIL)) = CONS (VAR__Y, VAR__TAIL);
         delete (VAR__X, CONS (VAR__Y, VAR__TAIL)) = CONS (VAR__Y, delete (VAR__X, VAR__TAIL));

      ofsort NATSET
      forall VAR__X, VAR__Y : NAT, VAR__TAIL : NATSET
         INSERT (VAR__X, NIL) = CONS (VAR__X, NIL);
         INSERT (VAR__X, CONS (VAR__X, VAR__TAIL)) = CONS (VAR__X, VAR__TAIL);
         (VAR__X < VAR__Y) => INSERT (VAR__X, CONS (VAR__Y, VAR__TAIL)) = CONS (VAR__X, CONS (VAR__Y, VAR__TAIL));
         INSERT (VAR__X, CONS (VAR__Y, VAR__TAIL)) = CONS (VAR__Y, INSERT (VAR__X, VAR__TAIL));

      ofsort NAT
      forall VAR__X : NAT, VAR__TAIL : NATSET
         length (NIL of NATSET) = 0 of NAT;
         length (CONS (VAR__X, VAR__TAIL)) = length (VAR__TAIL) + 1 of NAT;

      ofsort NATSET
      forall VAR__X : NAT, VAR__L : NATSET
         remove (VAR__X, VAR__L) = delete (VAR__X, VAR__L);

      ofsort BOOL
      forall VAR__X, VAR__Y : NAT, VAR__TAIL : NATSET
         member (VAR__X, NIL of NATSET) = FALSE;
         member (VAR__X, CONS (VAR__X, VAR__TAIL)) = TRUE;
         (VAR__X < VAR__Y) => member (VAR__X, CONS (VAR__Y, VAR__TAIL)) = FALSE;
         member (VAR__X, CONS (VAR__Y, VAR__TAIL)) = member (VAR__X, VAR__TAIL);

      ofsort NAT
      forall FIELD__1 : NAT, FIELD__2 : NATSET
         GET__1 (CONS (FIELD__1, FIELD__2) of NATSET) = FIELD__1;
      ofsort NATSET
      forall FIELD__1 : NAT, FIELD__2 : NATSET
         GET__2 (CONS (FIELD__1, FIELD__2) of NATSET) = FIELD__2;

      ofsort MEMARRAY
      forall VAR__X : INT
         MEMARRAY (VAR__X) = MEMARRAY (VAR__X, VAR__X);

      ofsort INT
      forall FIELD__1, FIELD__2 : INT
         ARRAY__GET (MEMARRAY (FIELD__1, FIELD__2), succ (0)) = FIELD__1;
         ARRAY__GET (MEMARRAY (FIELD__1, FIELD__2), succ (succ (0))) = FIELD__2;

      ofsort MEMARRAY
      forall FIELD__1, FIELD__2, NEW__FIELD__INT : INT
         ARRAY__SET (MEMARRAY (FIELD__1, FIELD__2), succ (0), NEW__FIELD__INT) = MEMARRAY (NEW__FIELD__INT, FIELD__2);
         ARRAY__SET (MEMARRAY (FIELD__1, FIELD__2), succ (succ (0)), NEW__FIELD__INT) = MEMARRAY (FIELD__1, NEW__FIELD__INT);

      ofsort INT
      forall FIELD__1 : INT, FIELD__2 : INT
         GET__1 (MEMARRAY (FIELD__1, FIELD__2) of MEMARRAY) = FIELD__1;
         GET__2 (MEMARRAY (FIELD__1, FIELD__2) of MEMARRAY) = FIELD__2;

      ofsort NAT
      forall VAR__X : NAT
         NAT (CONSTRUCTOR__MEMLOC (VAR__X)) = VAR__X;

      ofsort MEMLOC
      forall VAR__X : NAT
         (1) <= VAR__X, VAR__X <= (2) => MEMLOC (VAR__X) = CONSTRUCTOR__MEMLOC (VAR__X);

      ofsort MEMLOC
      forall VAR__X : MEMLOC
         MEMLOC (VAR__X) = VAR__X;

      ofsort MEMLOC
      forall FIELD__CHECK_LOC : MEMLOC, FIELD__EXCH_VAL : INT, FIELD__DO_EXCH : BOOL, FIELD__CHECK_VAL : INT, FIELD__BRANCH_TARGET : NAT, FIELD__DO_BRANCH : BOOL
         GET_CHECK_LOC (ATOMIC_EXCH_BRANCH (FIELD__CHECK_LOC, FIELD__EXCH_VAL, FIELD__DO_EXCH, FIELD__CHECK_VAL, FIELD__BRANCH_TARGET, FIELD__DO_BRANCH) of INSTRUCTION) = FIELD__CHECK_LOC;

      ofsort INT
      forall FIELD__CHECK_LOC : MEMLOC, FIELD__EXCH_VAL : INT, FIELD__DO_EXCH : BOOL, FIELD__CHECK_VAL : INT, FIELD__BRANCH_TARGET : NAT, FIELD__DO_BRANCH : BOOL
         GET_EXCH_VAL (ATOMIC_EXCH_BRANCH (FIELD__CHECK_LOC, FIELD__EXCH_VAL, FIELD__DO_EXCH, FIELD__CHECK_VAL, FIELD__BRANCH_TARGET, FIELD__DO_BRANCH) of INSTRUCTION) = FIELD__EXCH_VAL;

      ofsort BOOL
      forall FIELD__CHECK_LOC : MEMLOC, FIELD__EXCH_VAL : INT, FIELD__DO_EXCH : BOOL, FIELD__CHECK_VAL : INT, FIELD__BRANCH_TARGET : NAT, FIELD__DO_BRANCH : BOOL
         GET_DO_EXCH (ATOMIC_EXCH_BRANCH (FIELD__CHECK_LOC, FIELD__EXCH_VAL, FIELD__DO_EXCH, FIELD__CHECK_VAL, FIELD__BRANCH_TARGET, FIELD__DO_BRANCH) of INSTRUCTION) = FIELD__DO_EXCH;

      ofsort INT
      forall FIELD__CHECK_LOC : MEMLOC, FIELD__EXCH_VAL : INT, FIELD__DO_EXCH : BOOL, FIELD__CHECK_VAL : INT, FIELD__BRANCH_TARGET : NAT, FIELD__DO_BRANCH : BOOL
         GET_CHECK_VAL (ATOMIC_EXCH_BRANCH (FIELD__CHECK_LOC, FIELD__EXCH_VAL, FIELD__DO_EXCH, FIELD__CHECK_VAL, FIELD__BRANCH_TARGET, FIELD__DO_BRANCH) of INSTRUCTION) = FIELD__CHECK_VAL;

      ofsort NAT
      forall FIELD__CHECK_LOC : MEMLOC, FIELD__EXCH_VAL : INT, FIELD__DO_EXCH : BOOL, FIELD__CHECK_VAL : INT, FIELD__BRANCH_TARGET : NAT, FIELD__DO_BRANCH : BOOL
         GET_BRANCH_TARGET (ATOMIC_EXCH_BRANCH (FIELD__CHECK_LOC, FIELD__EXCH_VAL, FIELD__DO_EXCH, FIELD__CHECK_VAL, FIELD__BRANCH_TARGET, FIELD__DO_BRANCH) of INSTRUCTION) = FIELD__BRANCH_TARGET;

      ofsort BOOL
      forall FIELD__CHECK_LOC : MEMLOC, FIELD__EXCH_VAL : INT, FIELD__DO_EXCH : BOOL, FIELD__CHECK_VAL : INT, FIELD__BRANCH_TARGET : NAT, FIELD__DO_BRANCH : BOOL
         GET_DO_BRANCH (ATOMIC_EXCH_BRANCH (FIELD__CHECK_LOC, FIELD__EXCH_VAL, FIELD__DO_EXCH, FIELD__CHECK_VAL, FIELD__BRANCH_TARGET, FIELD__DO_BRANCH) of INSTRUCTION) = FIELD__DO_BRANCH;

      ofsort MEMLOC
      forall FIELD__1 : MEMLOC, FIELD__2 : INT, FIELD__3 : BOOL, FIELD__4 : INT, FIELD__5 : NAT, FIELD__6 : BOOL
         GET__1 (ATOMIC_EXCH_BRANCH (FIELD__1, FIELD__2, FIELD__3, FIELD__4, FIELD__5, FIELD__6) of INSTRUCTION) = FIELD__1;
      ofsort INT
      forall FIELD__1 : MEMLOC, FIELD__2 : INT, FIELD__3 : BOOL, FIELD__4 : INT, FIELD__5 : NAT, FIELD__6 : BOOL
         GET__2 (ATOMIC_EXCH_BRANCH (FIELD__1, FIELD__2, FIELD__3, FIELD__4, FIELD__5, FIELD__6) of INSTRUCTION) = FIELD__2;
      ofsort BOOL
      forall FIELD__1 : MEMLOC, FIELD__2 : INT, FIELD__3 : BOOL, FIELD__4 : INT, FIELD__5 : NAT, FIELD__6 : BOOL
         GET__3 (ATOMIC_EXCH_BRANCH (FIELD__1, FIELD__2, FIELD__3, FIELD__4, FIELD__5, FIELD__6) of INSTRUCTION) = FIELD__3;
      ofsort INT
      forall FIELD__1 : MEMLOC, FIELD__2 : INT, FIELD__3 : BOOL, FIELD__4 : INT, FIELD__5 : NAT, FIELD__6 : BOOL
         GET__4 (ATOMIC_EXCH_BRANCH (FIELD__1, FIELD__2, FIELD__3, FIELD__4, FIELD__5, FIELD__6) of INSTRUCTION) = FIELD__4;
      ofsort NAT
      forall FIELD__1 : MEMLOC, FIELD__2 : INT, FIELD__3 : BOOL, FIELD__4 : INT, FIELD__5 : NAT, FIELD__6 : BOOL
         GET__5 (ATOMIC_EXCH_BRANCH (FIELD__1, FIELD__2, FIELD__3, FIELD__4, FIELD__5, FIELD__6) of INSTRUCTION) = FIELD__5;
      ofsort BOOL
      forall FIELD__1 : MEMLOC, FIELD__2 : INT, FIELD__3 : BOOL, FIELD__4 : INT, FIELD__5 : NAT, FIELD__6 : BOOL
         GET__6 (ATOMIC_EXCH_BRANCH (FIELD__1, FIELD__2, FIELD__3, FIELD__4, FIELD__5, FIELD__6) of INSTRUCTION) = FIELD__6;

      ofsort INSTRUCTION
      forall VAR__X : INSTRUCTION, VAR__TAIL : PROGRAM, VAR__N : NAT
         access (CONS (VAR__X, VAR__TAIL), SUCC (0)) = VAR__X;
         access (CONS (VAR__X, VAR__TAIL), SUCC (VAR__N)) = access (VAR__TAIL, VAR__N);

      ofsort NAT
      forall VAR__X : INSTRUCTION, VAR__TAIL : PROGRAM
         length (NIL of PROGRAM) = 0 of NAT;
         length (CONS (VAR__X, VAR__TAIL)) = length (VAR__TAIL) + 1 of NAT;

      ofsort INSTRUCTION
      forall FIELD__1 : INSTRUCTION, FIELD__2 : PROGRAM
         GET__1 (CONS (FIELD__1, FIELD__2) of PROGRAM) = FIELD__1;
      ofsort PROGRAM
      forall FIELD__1 : INSTRUCTION, FIELD__2 : PROGRAM
         GET__2 (CONS (FIELD__1, FIELD__2) of PROGRAM) = FIELD__2;

      (* equations for LNT function definitions *)
      ofsort NAT
         NUMMEMLOC = 2 of NAT;

      ofsort BOOL
      forall P1 : NAT
         P1 = P1 => CHECK__CHANNEL__NATCHAN (P1) = TRUE;

      ofsort BOOL
      forall P1 : NAT, P2 : INSTRUCTION, P3 : NATSET, P4 : NAT
         P4 = P4, P3 = P3, P2 = P2, P1 = P1 => CHECK__CHANNEL__EXCHAN (P1, P2, P3, P4) = TRUE;

endtype

(* processes for LNT process definitions *)

process THREAD [EX, TERMINATE] (PARAM__TID : NAT, PARAM__PROG : PROGRAM) : exit :=
   let LOCAL__PC__1 : NAT = 1 of NAT in
      LOOP__1 [EX, TERMINATE] (PARAM__PROG, PARAM__TID, LOCAL__PC__1)

where

   process LOOP__1 [EX, TERMINATE] (PARAM__PROG : PROGRAM, PARAM__TID : NAT, LOCAL__PC__1 : NAT) : exit :=
      let CASE__VALUE__1 : INSTRUCTION = ACCESS (PARAM__PROG, LOCAL__PC__1) of INSTRUCTION in
         (
            let CASE__BRANCH__1 : COMPUTE__CASE__BRANCH__1__THREAD__66__TYPE = COMPUTE__CASE__BRANCH__1__THREAD__66 (CASE__VALUE__1) in
               [CASE__BRANCH__1 = COMPUTE__CASE__BRANCH__1__THREAD__66__CODE__0] ->
                  (
                     let
                        LOCAL__BRANCH_TARGET__1 : NAT = GET__5 (CASE__VALUE__1),
                        LOCAL__CHECK_VAL__1 : INT = GET__4 (CASE__VALUE__1),
                        LOCAL__DO_EXCH__1 : BOOL = GET__3 (CASE__VALUE__1),
                        LOCAL__EXCH_VAL__1 : INT = GET__2 (CASE__VALUE__1),
                        LOCAL__CHECK_LOC__1 : MEMLOC = GET__1 (CASE__VALUE__1)
                     in
                        EX !PARAM__TID !ATOMIC_EXCH_BRANCH (LOCAL__CHECK_LOC__1, LOCAL__EXCH_VAL__1, LOCAL__DO_EXCH__1, LOCAL__CHECK_VAL__1, LOCAL__BRANCH_TARGET__1, TRUE) ?COMM__VAR__2 : NATSET ?COMM__VAR__3 : NAT [CHECK__CHANNEL__EXCHAN (PARAM__TID, ATOMIC_EXCH_BRANCH (LOCAL__CHECK_LOC__1, LOCAL__EXCH_VAL__1, LOCAL__DO_EXCH__1, LOCAL__CHECK_VAL__1, LOCAL__BRANCH_TARGET__1, TRUE), COMM__VAR__2, COMM__VAR__3) = TRUE of BOOL];
                           (
                              let LOCAL__PC__1 : NAT = LOCAL__BRANCH_TARGET__1 in
                                 COND__1 [EX, TERMINATE] (LOCAL__PC__1, LOCAL__BRANCH_TARGET__1, LOCAL__CHECK_VAL__1, LOCAL__DO_EXCH__1, LOCAL__EXCH_VAL__1, LOCAL__CHECK_LOC__1, PARAM__PROG, PARAM__TID)
                           )
                        []
                        EX !PARAM__TID !ATOMIC_EXCH_BRANCH (LOCAL__CHECK_LOC__1, LOCAL__EXCH_VAL__1, LOCAL__DO_EXCH__1, LOCAL__CHECK_VAL__1, LOCAL__BRANCH_TARGET__1, FALSE) ?COMM__VAR__2 : NATSET ?COMM__VAR__3 : NAT [CHECK__CHANNEL__EXCHAN (PARAM__TID, ATOMIC_EXCH_BRANCH (LOCAL__CHECK_LOC__1, LOCAL__EXCH_VAL__1, LOCAL__DO_EXCH__1, LOCAL__CHECK_VAL__1, LOCAL__BRANCH_TARGET__1, FALSE), COMM__VAR__2, COMM__VAR__3) = TRUE of BOOL];
                           (
                              let LOCAL__PC__1 : NAT = (LOCAL__PC__1 + 1) of NAT in
                                 COND__1 [EX, TERMINATE] (LOCAL__PC__1, LOCAL__BRANCH_TARGET__1, LOCAL__CHECK_VAL__1, LOCAL__DO_EXCH__1, LOCAL__EXCH_VAL__1, LOCAL__CHECK_LOC__1, PARAM__PROG, PARAM__TID)
                           )
                  )
         )
   endproc

   type COMPUTE__CASE__BRANCH__1__THREAD__66 is LNTEXTENSIONS, COMMON
      sorts COMPUTE__CASE__BRANCH__1__THREAD__66__TYPE
      opns
         COMPUTE__CASE__BRANCH__1__THREAD__66 : INSTRUCTION -> COMPUTE__CASE__BRANCH__1__THREAD__66__TYPE
         COMPUTE__CASE__BRANCH__1__THREAD__66__CODE__0 (*! implementedby COMPUTE__CASE__BRANCH__1__THREAD__66__CODE__0 constructor *) : -> COMPUTE__CASE__BRANCH__1__THREAD__66__TYPE
      eqns
         forall ANY__VAR__1 : BOOL, LOCAL__BRANCH_TARGET__1 : NAT, LOCAL__CHECK_VAL__1 : INT, LOCAL__DO_EXCH__1 : BOOL, LOCAL__EXCH_VAL__1 : INT, LOCAL__CHECK_LOC__1 : MEMLOC
         ofsort COMPUTE__CASE__BRANCH__1__THREAD__66__TYPE
            COMPUTE__CASE__BRANCH__1__THREAD__66 (ATOMIC_EXCH_BRANCH (LOCAL__CHECK_LOC__1, LOCAL__EXCH_VAL__1, LOCAL__DO_EXCH__1, LOCAL__CHECK_VAL__1, LOCAL__BRANCH_TARGET__1, ANY__VAR__1)) = COMPUTE__CASE__BRANCH__1__THREAD__66__CODE__0;

   endtype


   process COND__1 [EX, TERMINATE] (LOCAL__PC__1 : NAT, LOCAL__BRANCH_TARGET__1 : NAT, LOCAL__CHECK_VAL__1 : INT, LOCAL__DO_EXCH__1 : BOOL, LOCAL__EXCH_VAL__1 : INT, LOCAL__CHECK_LOC__1 : MEMLOC, PARAM__PROG : PROGRAM, PARAM__TID : NAT) : exit :=
      [LOCAL__PC__1 > LENGTH (PARAM__PROG) = TRUE of BOOL] ->
         WHILE_CONT__1 [EX, TERMINATE] (PARAM__TID)
      []
      [NOT (LOCAL__PC__1 > LENGTH (PARAM__PROG)) = TRUE of BOOL] ->
         LOOP__1 [EX, TERMINATE] (PARAM__PROG, PARAM__TID, LOCAL__PC__1)
   endproc


   process WHILE_CONT__1 [EX, TERMINATE] (PARAM__TID : NAT) : exit :=
      TERMINATE !PARAM__TID [CHECK__CHANNEL__NATCHAN (PARAM__TID) = TRUE of BOOL];
         exit
   endproc

endproc

process SHARED_MEMORY [EX, TERMINATE] (PARAM__NUMTHREAD : NAT) : exit :=
   let LOCAL__DONETHREAD__1 : NAT = 0 of NAT in
      (
         let LOCAL__MEM__1 : MEMARRAY = MEMARRAY (0) of MEMARRAY in
            LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__MEM__1)
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREAD__1 : NAT, LOCAL__MEM__1 : MEMARRAY) : exit :=
      EX ?COMM__VAR__0 : NAT ?COMM__VAR__1 : INSTRUCTION ?COMM__VAR__2 : NATSET ?COMM__VAR__3 : NAT [(COMMUNICATION__MATCH__0 (COMM__VAR__1) AND_THEN (GET__6 (COMM__VAR__1) == (GET__4 (COMM__VAR__1) == ARRAY__GET (LOCAL__MEM__1, NAT (GET__1 (COMM__VAR__1)))))) AND_THEN CHECK__CHANNEL__EXCHAN (COMM__VAR__0, COMM__VAR__1, COMM__VAR__2, COMM__VAR__3) = TRUE of BOOL];
         (
            let
               LOCAL__DO_BRANCH__1 : BOOL = GET__6 (COMM__VAR__1),
               LOCAL__CHECK_VAL__1 : INT = GET__4 (COMM__VAR__1),
               LOCAL__DO_EXCH__1 : BOOL = GET__3 (COMM__VAR__1),
               LOCAL__EXCH_VAL__1 : INT = GET__2 (COMM__VAR__1),
               LOCAL__CHECK_LOC__1 : MEMLOC = GET__1 (COMM__VAR__1)
            in
               [LOCAL__DO_EXCH__1 = TRUE of BOOL] ->
                  (
                     let LOCAL__MEM__1 : MEMARRAY = ARRAY__SET (LOCAL__MEM__1, NAT (LOCAL__CHECK_LOC__1), LOCAL__EXCH_VAL__1) in
                        LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__MEM__1)
                  )
               []
               [NOT (LOCAL__DO_EXCH__1) = TRUE of BOOL] ->
                  LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__MEM__1)
         )
      []
      TERMINATE ?COMM__VAR__0 : NAT [CHECK__CHANNEL__NATCHAN (COMM__VAR__0) = TRUE of BOOL];
         (
            let LOCAL__DONETHREAD__1 : NAT = (LOCAL__DONETHREAD__1 + 1) of NAT in
               [LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD = TRUE of BOOL] ->
                  exit
               []
               [NOT (LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD) = TRUE of BOOL] ->
                  LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__MEM__1)
         )
   endproc

   type COMMUNICATION__MATCH__0 is LNTEXTENSIONS, COMMON
      opns
         COMMUNICATION__MATCH__0 : INSTRUCTION -> BOOL
      eqns
         forall LOCAL__DO_BRANCH__1 : BOOL, ANY__VAR__1 : NAT, LOCAL__CHECK_VAL__1 : INT, LOCAL__DO_EXCH__1 : BOOL, LOCAL__EXCH_VAL__1 : INT, LOCAL__CHECK_LOC__1 : MEMLOC, COMM__VAR__1 : INSTRUCTION
         ofsort BOOL
            COMMUNICATION__MATCH__0 (ATOMIC_EXCH_BRANCH (LOCAL__CHECK_LOC__1, LOCAL__EXCH_VAL__1, LOCAL__DO_EXCH__1, LOCAL__CHECK_VAL__1, ANY__VAR__1, LOCAL__DO_BRANCH__1)) = TRUE;

   endtype

endproc

process SCHEDULER_NONE [EX, TERMINATE] (PARAM__NUMTHREAD : NAT) : exit :=
   let LOCAL__DONETHREAD__1 : NAT = 0 of NAT in
      (
         let LOCAL__TS__1 : NATSET = NIL of NATSET in
            (
               let LOCAL__ZERO__1 : NAT = 0 of NAT in
                  LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__TS__1, LOCAL__ZERO__1)
            )
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREAD__1 : NAT, LOCAL__TS__1 : NATSET, LOCAL__ZERO__1 : NAT) : exit :=
      EX ?COMM__VAR__0 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__TS__1 !LOCAL__ZERO__1 [CHECK__CHANNEL__EXCHAN (COMM__VAR__0, COMM__VAR__1, LOCAL__TS__1, LOCAL__ZERO__1) = TRUE of BOOL];
         LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__TS__1, LOCAL__ZERO__1)
      []
      TERMINATE ?COMM__VAR__0 : NAT [CHECK__CHANNEL__NATCHAN (COMM__VAR__0) = TRUE of BOOL];
         (
            let LOCAL__DONETHREAD__1 : NAT = (LOCAL__DONETHREAD__1 + 1) of NAT in
               [LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD = TRUE of BOOL] ->
                  exit
               []
               [NOT (LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD) = TRUE of BOOL] ->
                  LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__TS__1, LOCAL__ZERO__1)
         )
   endproc

endproc

process SCHEDULER_OBE [EX, TERMINATE] (PARAM__NUMTHREAD : NAT) : exit :=
   let LOCAL__DONETHREAD__1 : NAT = 0 of NAT in
      (
         choice LOCAL__NUMCU__1 : NAT []
            [LOCAL__NUMCU__1 <= PARAM__NUMTHREAD = TRUE of BOOL] ->
               (
                  let LOCAL__ACTIVETHREADS__1 : NATSET = NIL of NATSET in
                     LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__NUMCU__1, LOCAL__ACTIVETHREADS__1)
               )
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREAD__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__ACTIVETHREADS__1 : NATSET) : exit :=
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__ACTIVETHREADS__1 !LOCAL__NUMCU__1 [((LENGTH (LOCAL__ACTIVETHREADS__1) < LOCAL__NUMCU__1) AND NOT (MEMBER (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1))) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__ACTIVETHREADS__1, LOCAL__NUMCU__1) = TRUE of BOOL];
         (
            let LOCAL__ACTIVETHREADS__1 : NATSET = INSERT (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1) of NATSET in
               LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__NUMCU__1, LOCAL__ACTIVETHREADS__1)
         )
      []
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__ACTIVETHREADS__1 !LOCAL__NUMCU__1 [MEMBER (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__ACTIVETHREADS__1, LOCAL__NUMCU__1) = TRUE of BOOL];
         LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__NUMCU__1, LOCAL__ACTIVETHREADS__1)
      []
      TERMINATE ?LOCAL__TID__1 : NAT [CHECK__CHANNEL__NATCHAN (LOCAL__TID__1) = TRUE of BOOL];
         (
            let LOCAL__ACTIVETHREADS__1 : NATSET = REMOVE (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1) of NATSET in
               (
                  let LOCAL__DONETHREAD__1 : NAT = (LOCAL__DONETHREAD__1 + 1) of NAT in
                     [LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD = TRUE of BOOL] ->
                        exit
                     []
                     [NOT (LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD) = TRUE of BOOL] ->
                        LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__NUMCU__1, LOCAL__ACTIVETHREADS__1)
               )
         )
   endproc

endproc

process SCHEDULER_HSA [EX, TERMINATE] (PARAM__NUMTHREAD : NAT) : exit :=
   let LOCAL__DONETHREAD__1 : NAT = 0 of NAT in
      (
         let LOCAL__FAIRSCHED__1 : NATSET = CONS (LOCAL__DONETHREAD__1, NIL) of NATSET in
            (
               let LOCAL__ONE__1 : NAT = 1 of NAT in
                  LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__FAIRSCHED__1, LOCAL__ONE__1)
            )
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREAD__1 : NAT, LOCAL__FAIRSCHED__1 : NATSET, LOCAL__ONE__1 : NAT) : exit :=
      EX ?COMM__VAR__0 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__FAIRSCHED__1 !LOCAL__ONE__1 [CHECK__CHANNEL__EXCHAN (COMM__VAR__0, COMM__VAR__1, LOCAL__FAIRSCHED__1, LOCAL__ONE__1) = TRUE of BOOL];
         LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__FAIRSCHED__1, LOCAL__ONE__1)
      []
      TERMINATE ?COMM__VAR__0 : NAT [CHECK__CHANNEL__NATCHAN (COMM__VAR__0) = TRUE of BOOL];
         (
            let LOCAL__DONETHREAD__1 : NAT = (LOCAL__DONETHREAD__1 + 1) of NAT in
               (
                  let LOCAL__FAIRSCHED__1 : NATSET = CONS (LOCAL__DONETHREAD__1, NIL) of NATSET in
                     [LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD = TRUE of BOOL] ->
                        exit
                     []
                     [NOT (LOCAL__DONETHREAD__1 == PARAM__NUMTHREAD) = TRUE of BOOL] ->
                        LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREAD__1, LOCAL__FAIRSCHED__1, LOCAL__ONE__1)
               )
         )
   endproc

endproc

process SCHEDULER_HSA_COMPLETE [EX, TERMINATE] (PARAM__NUMTHREAD : NAT) : exit :=
   let LOCAL__ACTIVETHREAD__1 : NAT = 0 of NAT in
      (
         choice LOCAL__NUMCU__1 : NAT []
            [LOCAL__NUMCU__1 <= PARAM__NUMTHREAD = TRUE of BOOL] ->
               (
                  let LOCAL__SCHEDSET__1 : NATSET = CONS (LOCAL__ACTIVETHREAD__1, NIL) of NATSET in
                     (
                        let LOCAL__TOKENSET__1 : NATSET = CONS (LOCAL__ACTIVETHREAD__1, NIL) of NATSET in
                           (
                              let LOCAL__ONE__1 : NAT = 1 of NAT in
                                 LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__ACTIVETHREAD__1, LOCAL__NUMCU__1, LOCAL__SCHEDSET__1, LOCAL__TOKENSET__1, LOCAL__ONE__1)
                           )
                     )
               )
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__ACTIVETHREAD__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__SCHEDSET__1 : NATSET, LOCAL__TOKENSET__1 : NATSET, LOCAL__ONE__1 : NAT) : exit :=
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__SCHEDSET__1 !LOCAL__ONE__1 [((LENGTH (LOCAL__TOKENSET__1) < LOCAL__NUMCU__1) AND NOT (MEMBER (LOCAL__TID__1, LOCAL__TOKENSET__1))) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__SCHEDSET__1, LOCAL__ONE__1) = TRUE of BOOL];
         (
            let LOCAL__TOKENSET__1 : NATSET = INSERT (LOCAL__TID__1, LOCAL__TOKENSET__1) of NATSET in
               LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__ACTIVETHREAD__1, LOCAL__NUMCU__1, LOCAL__SCHEDSET__1, LOCAL__TOKENSET__1, LOCAL__ONE__1)
         )
      []
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__SCHEDSET__1 !LOCAL__ONE__1 [MEMBER (LOCAL__TID__1, LOCAL__TOKENSET__1) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__SCHEDSET__1, LOCAL__ONE__1) = TRUE of BOOL];
         LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__ACTIVETHREAD__1, LOCAL__NUMCU__1, LOCAL__SCHEDSET__1, LOCAL__TOKENSET__1, LOCAL__ONE__1)
      []
      TERMINATE ?LOCAL__TID__1 : NAT [CHECK__CHANNEL__NATCHAN (LOCAL__TID__1) = TRUE of BOOL];
         (
            let LOCAL__TOKENSET__1 : NATSET = REMOVE (LOCAL__TID__1, LOCAL__TOKENSET__1) of NATSET in
               [LOCAL__TID__1 == LOCAL__ACTIVETHREAD__1 = TRUE of BOOL] ->
                  (
                     let LOCAL__ACTIVETHREAD__1 : NAT = (LOCAL__ACTIVETHREAD__1 + 1) of NAT in
                        (
                           let LOCAL__SCHEDSET__1 : NATSET = CONS (LOCAL__ACTIVETHREAD__1, NIL) of NATSET in
                              (
                                 let LOCAL__TOKENSET__1 : NATSET = INSERT (LOCAL__ACTIVETHREAD__1, LOCAL__TOKENSET__1) of NATSET in
                                    COND__2 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__ACTIVETHREAD__1, LOCAL__NUMCU__1, LOCAL__SCHEDSET__1, LOCAL__TOKENSET__1, LOCAL__ONE__1)
                              )
                        )
                  )
               []
               [NOT (LOCAL__TID__1 == LOCAL__ACTIVETHREAD__1) = TRUE of BOOL] ->
                  COND__2 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__ACTIVETHREAD__1, LOCAL__NUMCU__1, LOCAL__SCHEDSET__1, LOCAL__TOKENSET__1, LOCAL__ONE__1)
         )
   endproc


   process COND__2 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__ACTIVETHREAD__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__SCHEDSET__1 : NATSET, LOCAL__TOKENSET__1 : NATSET, LOCAL__ONE__1 : NAT) : exit :=
      [LOCAL__ACTIVETHREAD__1 == PARAM__NUMTHREAD = TRUE of BOOL] ->
         exit
      []
      [NOT (LOCAL__ACTIVETHREAD__1 == PARAM__NUMTHREAD) = TRUE of BOOL] ->
         LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__ACTIVETHREAD__1, LOCAL__NUMCU__1, LOCAL__SCHEDSET__1, LOCAL__TOKENSET__1, LOCAL__ONE__1)
   endproc

endproc

process SCHEDULER_HSA_OBE [EX, TERMINATE] (PARAM__NUMTHREAD : NAT, PARAM__NUMCU : NAT) : exit :=
   let LOCAL__DONETHREADS__1 : NATSET = NIL of NATSET in
      (
         let LOCAL__HSATHREAD__1 : NAT = 0 of NAT in
            (
               let LOCAL__ACTIVETHREADS__1 : NATSET = CONS (LOCAL__HSATHREAD__1, NIL) of NATSET in
                  LOOP__1 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
            )
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMCU : NAT, PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NATSET, LOCAL__HSATHREAD__1 : NAT, LOCAL__ACTIVETHREADS__1 : NATSET) : exit :=
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__ACTIVETHREADS__1 !PARAM__NUMCU [((LENGTH (LOCAL__ACTIVETHREADS__1) < PARAM__NUMCU) AND NOT (MEMBER (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1))) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__ACTIVETHREADS__1, PARAM__NUMCU) = TRUE of BOOL];
         (
            let LOCAL__ACTIVETHREADS__1 : NATSET = INSERT (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1) of NATSET in
               LOOP__1 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
         )
      []
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__ACTIVETHREADS__1 !PARAM__NUMCU [MEMBER (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__ACTIVETHREADS__1, PARAM__NUMCU) = TRUE of BOOL];
         LOOP__1 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
      []
      TERMINATE ?LOCAL__TID__1 : NAT [CHECK__CHANNEL__NATCHAN (LOCAL__TID__1) = TRUE of BOOL];
         (
            let LOCAL__ACTIVETHREADS__1 : NATSET = REMOVE (LOCAL__TID__1, LOCAL__ACTIVETHREADS__1) of NATSET in
               (
                  let LOCAL__DONETHREADS__1 : NATSET = INSERT (LOCAL__TID__1, LOCAL__DONETHREADS__1) of NATSET in
                     [LENGTH (LOCAL__DONETHREADS__1) == PARAM__NUMTHREAD = TRUE of BOOL] ->
                        exit
                     []
                     [NOT (LENGTH (LOCAL__DONETHREADS__1) == PARAM__NUMTHREAD) = TRUE of BOOL] ->
                        COND__2 [TERMINATE, EX] (LOCAL__TID__1, PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
               )
         )
   endproc


   process COND__2 [TERMINATE, EX] (LOCAL__TID__1 : NAT, PARAM__NUMCU : NAT, PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NATSET, LOCAL__HSATHREAD__1 : NAT, LOCAL__ACTIVETHREADS__1 : NATSET) : exit :=
      [LOCAL__TID__1 == LOCAL__HSATHREAD__1 = TRUE of BOOL] ->
         LOOP__2 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
      []
      [NOT (LOCAL__TID__1 == LOCAL__HSATHREAD__1) = TRUE of BOOL] ->
         LOOP__1 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
   endproc


   process LOOP__2 [TERMINATE, EX] (PARAM__NUMCU : NAT, PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NATSET, LOCAL__HSATHREAD__1 : NAT, LOCAL__ACTIVETHREADS__1 : NATSET) : exit :=
      [MEMBER (LOCAL__HSATHREAD__1, LOCAL__DONETHREADS__1) = TRUE of BOOL] ->
         (
            let LOCAL__HSATHREAD__1 : NAT = (LOCAL__HSATHREAD__1 + 1) of NAT in
               LOOP__2 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
         )
      []
      [MEMBER (LOCAL__HSATHREAD__1, LOCAL__DONETHREADS__1) = FALSE of BOOL] ->
         LOOP__1 [TERMINATE, EX] (PARAM__NUMCU, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__HSATHREAD__1, LOCAL__ACTIVETHREADS__1)
   endproc

endproc

process SCHEDULER_LOBE [EX, TERMINATE] (PARAM__NUMTHREAD : NAT) : exit :=
   let LOCAL__DONETHREADS__1 : NAT = 0 of NAT in
      (
         choice LOCAL__NUMCU__1 : NAT []
            [LOCAL__NUMCU__1 <= PARAM__NUMTHREAD = TRUE of BOOL] ->
               (
                  let LOCAL__HIGHESTID__1 : NAT = LOCAL__NUMCU__1 in
                     (
                        let LOCAL__I__1 : NAT = 0 of NAT in
                           (
                              let LOCAL__THREADSET__1 : NATSET = NIL of NATSET in
                                 LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__I__1, LOCAL__THREADSET__1)
                           )
                     )
               )
      )

where

   process LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__HIGHESTID__1 : NAT, LOCAL__I__1 : NAT, LOCAL__THREADSET__1 : NATSET) : exit :=
      [LOCAL__I__1 < LOCAL__HIGHESTID__1 = TRUE of BOOL] ->
         (
            let LOCAL__THREADSET__1 : NATSET = INSERT (LOCAL__I__1, LOCAL__THREADSET__1) of NATSET in
               (
                  let LOCAL__I__1 : NAT = (LOCAL__I__1 + 1) of NAT in
                     LOOP__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__I__1, LOCAL__THREADSET__1)
               )
         )
      []
      [LOCAL__I__1 < LOCAL__HIGHESTID__1 = FALSE of BOOL] ->
         WHILE_CONT__1 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__THREADSET__1)
   endproc


   process WHILE_CONT__1 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__HIGHESTID__1 : NAT, LOCAL__THREADSET__1 : NATSET) : exit :=
      LOOP__2 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__THREADSET__1)
   endproc


   process LOOP__2 [TERMINATE, EX] (PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__HIGHESTID__1 : NAT, LOCAL__THREADSET__1 : NATSET) : exit :=
      EX ?LOCAL__TID__1 : NAT ?COMM__VAR__1 : INSTRUCTION !LOCAL__THREADSET__1 !LOCAL__NUMCU__1 [(LOCAL__TID__1 < LOCAL__HIGHESTID__1) AND_THEN CHECK__CHANNEL__EXCHAN (LOCAL__TID__1, COMM__VAR__1, LOCAL__THREADSET__1, LOCAL__NUMCU__1) = TRUE of BOOL];
         LOOP__2 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__THREADSET__1)
      []
      TERMINATE ?LOCAL__TID__1 : NAT [CHECK__CHANNEL__NATCHAN (LOCAL__TID__1) = TRUE of BOOL];
         (
            let LOCAL__DONETHREADS__1 : NAT = (LOCAL__DONETHREADS__1 + 1) of NAT in
               [LOCAL__DONETHREADS__1 == PARAM__NUMTHREAD = TRUE of BOOL] ->
                  exit
               []
               [NOT (LOCAL__DONETHREADS__1 == PARAM__NUMTHREAD) = TRUE of BOOL] ->
                  COND__2 [TERMINATE, EX] (LOCAL__TID__1, PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__THREADSET__1)
         )
   endproc


   process COND__2 [TERMINATE, EX] (LOCAL__TID__1 : NAT, PARAM__NUMTHREAD : NAT, LOCAL__DONETHREADS__1 : NAT, LOCAL__NUMCU__1 : NAT, LOCAL__HIGHESTID__1 : NAT, LOCAL__THREADSET__1 : NATSET) : exit :=
      let LOCAL__THREADSET__1 : NATSET = INSERT (LOCAL__HIGHESTID__1, LOCAL__THREADSET__1) of NATSET in
         (
            let LOCAL__THREADSET__1 : NATSET = REMOVE (LOCAL__TID__1, LOCAL__THREADSET__1) of NATSET in
               (
                  let LOCAL__HIGHESTID__1 : NAT = (LOCAL__HIGHESTID__1 + 1) of NAT in
                     LOOP__2 [TERMINATE, EX] (PARAM__NUMTHREAD, LOCAL__DONETHREADS__1, LOCAL__NUMCU__1, LOCAL__HIGHESTID__1, LOCAL__THREADSET__1)
               )
         )
   endproc

endproc
